function create_sensor_fusion_system(params)
%% Advanced Sensor Fusion with Multiple Estimation Strategies

fprintf('Creating advanced sensor fusion system...\n');

modelName = 'advanced_sensor_fusion';
new_system(modelName);
open_system(modelName);

%% === MULTI-SENSOR SUITE ===
sensors_sys = [modelName '/Advanced_Sensor_Suite'];
add_block('simulink/Ports & Subsystems/Subsystem', sensors_sys);

%% High-Fidelity IMU Model
imu_sys = [sensors_sys '/High_Fidelity_IMU'];
add_block('simulink/Ports & Subsystems/Subsystem', imu_sys);

% Accelerometer model with complete error characterization
add_block('simulink/User-Defined Functions/MATLAB Function', [imu_sys '/Accelerometer_Model']);
set_param([imu_sys '/Accelerometer_Model'], 'Script', [...
    'function [accel_meas] = fcn(accel_true, temperature, time)\n' ...
    '% High-fidelity accelerometer model\n' ...
    'persistent bias scale_factor cross_coupling\n' ...
    'if isempty(bias)\n' ...
    '    bias = ' num2str(params.sensors.imu.accel.bias_stability) ' * randn(3,1);\n' ...
    '    scale_factor = 1 + ' num2str(params.sensors.imu.accel.scale_factor_error) ' * randn(3,1);\n' ...
    '    cross_coupling = eye(3) + ' num2str(params.sensors.imu.accel.cross_axis_sensitivity) ' * randn(3,3);\n' ...
    'end\n' ...
    '% Temperature effects\n' ...
    'temp_bias = ' num2str(params.sensors.imu.accel.temperature_sensitivity) ' * (temperature - 25);\n' ...
    '% Noise model\n' ...
    'noise_std = ' num2str(params.sensors.imu.accel.noise_density) ' * sqrt(1000);\n' ...
    'noise = noise_std * randn(3,1);\n' ...
    '% Complete error model\n' ...
    'accel_meas = cross_coupling * (scale_factor .* accel_true + bias + temp_bias) + noise;\n']);

% Gyroscope model with Allan variance characterization
add_block('simulink/User-Defined Functions/MATLAB Function', [imu_sys '/Gyroscope_Model']);
set_param([imu_sys '/Gyroscope_Model'], 'Script', [...
    'function [gyro_meas] = fcn(gyro_true, accel_true, temperature)\n' ...
    '% High-fidelity gyroscope model\n' ...
    'persistent bias scale_factor g_sensitivity\n' ...
    'if isempty(bias)\n' ...
    '    bias_stability = ' num2str(params.sensors.imu.gyro.bias_stability) ' * pi/180/3600;\n' ...
    '    bias = bias_stability * randn(3,1);\n' ...
    '    scale_factor = 1 + ' num2str(params.sensors.imu.gyro.scale_factor_error) ' * randn(3,1);\n' ...
    '    g_sensitivity = ' num2str(params.sensors.imu.gyro.g_sensitivity) ' * pi/180 * randn(3,3);\n' ...
    'end\n' ...
    '% G-sensitivity (vibration rectification)\n' ...
    'g_error = g_sensitivity * accel_true;\n' ...
    '% Noise model\n' ...
    'noise_std = ' num2str(params.sensors.imu.gyro.noise_density) ' * pi/180 * sqrt(1000);\n' ...
    'noise = noise_std * randn(3,1);\n' ...
    '% Complete error model\n' ...
    'gyro_meas = scale_factor .* gyro_true + bias + g_error + noise;\n']);

%% Advanced Magnetometer with Calibration
mag_sys = [sensors_sys '/Advanced_Magnetometer'];
add_block('simulink/Ports & Subsystems/Subsystem', mag_sys);

add_block('simulink/User-Defined Functions/MATLAB Function', [mag_sys '/Magnetometer_Model']);
set_param([mag_sys '/Magnetometer_Model'], 'Script', [...
    'function [mag_meas] = fcn(attitude, position)\n' ...
    '% Advanced magnetometer model with realistic field\n' ...
    'declination = ' num2str(params.sensors.mag.declination) ';\n' ...
    'inclination = ' num2str(params.sensors.mag.inclination) ';\n' ...
    'intensity = ' num2str(params.sensors.mag.intensity) ';\n' ...
    '% Earth magnetic field in NED\n' ...
    'mag_ned = intensity * [cos(inclination)*cos(declination); cos(inclination)*sin(declination); sin(inclination)];\n' ...
    '% Rotation to body frame\n' ...
    'phi = attitude(1); theta = attitude(2); psi = attitude(3);\n' ...
    'R_nb = [cos(theta)*cos(psi), cos(theta)*sin(psi), -sin(theta);\n' ...
    '        sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi), sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi), sin(phi)*cos(theta);\n' ...
    '        cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi), cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi), cos(phi)*cos(theta)];\n' ...
    'mag_body = R_nb * mag_ned;\n' ...
    '% Sensor errors\n' ...
    'hard_iron = [' num2str(params.sensors.mag.hard_iron) ']'';\n' ...
    'soft_iron = [' mat2str(params.sensors.mag.soft_iron) '];\n' ...
    'noise = 0.1e-6 * randn(3,1);\n' ...
    'mag_meas = soft_iron * mag_body + hard_iron + noise;\n']);

%% Multi-Frequency GPS with Realistic Errors
gps_sys = [sensors_sys '/Multi_Frequency_GPS'];
add_block('simulink/Ports & Subsystems/Subsystem', gps_sys);

add_block('simulink/User-Defined Functions/MATLAB Function', [gps_sys '/GPS_Model']);
set_param([gps_sys '/GPS_Model'], 'Script', [...
    'function [pos_meas, vel_meas, valid] = fcn(pos_true, vel_true, time)\n' ...
    '% Multi-frequency GPS model with realistic errors\n' ...
    'persistent multipath_state ionospheric_delay\n' ...
    'if isempty(multipath_state)\n' ...
    '    multipath_state = 0;\n' ...
    '    ionospheric_delay = ' num2str(params.sensors.gps.ionospheric_delay) ' * randn();\n' ...
    'end\n' ...
    '% Availability model (urban canyon effects)\n' ...
    'if rand() < 0.95\n' ...
    '    valid = 1;\n' ...
    'else\n' ...
    '    valid = 0;\n' ...
    '    pos_meas = [0; 0; 0];\n' ...
    '    vel_meas = [0; 0; 0];\n' ...
    '    return;\n' ...
    'end\n' ...
    '% Multipath error (correlated)\n' ...
    'multipath_state = 0.9 * multipath_state + 0.1 * randn();\n' ...
    'multipath_error = ' num2str(params.sensors.gps.multipath_error) ' * multipath_state;\n' ...
    '% Position measurement\n' ...
    'pos_noise = ' num2str(params.sensors.gps.position_accuracy) ' * randn(3,1);\n' ...
    'pos_meas = pos_true + pos_noise + [multipath_error; multipath_error; 0];\n' ...
    '% Velocity measurement\n' ...
    'vel_noise = ' num2str(params.sensors.gps.velocity_accuracy) ' * randn(3,1);\n' ...
    'vel_meas = vel_true + vel_noise;\n']);

%% === ESTIMATION STRATEGIES ===
estimation_sys = [modelName '/Multi_Strategy_Estimation'];
add_block('simulink/Ports & Subsystems/Subsystem', estimation_sys);

%% Strategy 1: Unscented Kalman Filter (UKF)
ukf_sys = [estimation_sys '/UKF_Estimator'];
add_block('simulink/Ports & Subsystems/Subsystem', ukf_sys);

add_block('simulink/User-Defined Functions/MATLAB Function', [ukf_sys '/UKF_Prediction']);
set_param([ukf_sys '/UKF_Prediction'], 'Script', [...
    'function [x_pred, P_pred] = fcn(x, P, u, Q, dt)\n' ...
    '% Unscented Kalman Filter prediction step\n' ...
    'n = length(x);\n' ...
    'alpha = 1e-3; beta = 2; kappa = 0;\n' ...
    'lambda = alpha^2 * (n + kappa) - n;\n' ...
    '% Generate sigma points\n' ...
    'sqrt_P = chol((n + lambda) * P, ''lower'');\n' ...
    'X = [x, x + sqrt_P, x - sqrt_P];\n' ...
    '% Propagate sigma points\n' ...
    'X_pred = zeros(n, 2*n+1);\n' ...
    'for i = 1:2*n+1\n' ...
    '    X_pred(:,i) = dynamics_model(X(:,i), u, dt);\n' ...
    'end\n' ...
    '% Compute weights\n' ...
    'Wm = [lambda/(n+lambda), 0.5/(n+lambda) * ones(1,2*n)];\n' ...
    'Wc = Wm; Wc(1) = Wc(1) + (1 - alpha^2 + beta);\n' ...
    '% Predicted state and covariance\n' ...
    'x_pred = X_pred * Wm'';\n' ...
    'P_pred = Q;\n' ...
    'for i = 1:2*n+1\n' ...
    '    P_pred = P_pred + Wc(i) * (X_pred(:,i) - x_pred) * (X_pred(:,i) - x_pred)'';\n' ...
    'end\n' ...
    'function x_next = dynamics_model(x, u, dt)\n' ...
    '    % Simplified nonlinear dynamics\n' ...
    '    A = eye(length(x)) + dt * [-0.1*eye(6), eye(6); -eye(6), -0.5*eye(6)];\n' ...
    '    B = [zeros(6,4); dt*eye(4); zeros(2,4)];\n' ...
    '    x_next = A * x + B * u;\n' ...
    'end\n']);

%% Strategy 2: Particle Filter
pf_sys = [estimation_sys '/Particle_Filter'];
add_block('simulink/Ports & Subsystems/Subsystem', pf_sys);

add_block('simulink/User-Defined Functions/MATLAB Function', [pf_sys '/Particle_Filter_Update']);
set_param([pf_sys '/Particle_Filter_Update'], 'Script', [...
    'function [x_est, particles_out] = fcn(particles_in, weights_in, measurements, R)\n' ...
    '% Particle filter update step\n' ...
    'N_particles = size(particles_in, 2);\n' ...
    '% Weight update based on measurement likelihood\n' ...
    'weights = weights_in;\n' ...
    'for i = 1:N_particles\n' ...
    '    h = measurement_model(particles_in(:,i));\n' ...
    '    likelihood = exp(-0.5 * (measurements - h)'' / R * (measurements - h));\n' ...
    '    weights(i) = weights(i) * likelihood;\n' ...
    'end\n' ...
    '% Normalize weights\n' ...
    'weights = weights / sum(weights);\n' ...
    '% Resampling (systematic resampling)\n' ...
    'if 1/sum(weights.^2) < N_particles/2\n' ...
    '    [particles_out, weights] = systematic_resample(particles_in, weights);\n' ...
    'else\n' ...
    '    particles_out = particles_in;\n' ...
    'end\n' ...
    '% State estimate\n' ...
    'x_est = particles_out * weights'';\n' ...
    'function h = measurement_model(x)\n' ...
    '    h = x(1:6);  % Position and velocity measurements\n' ...
    'end\n' ...
    'function [p_new, w_new] = systematic_resample(particles, weights)\n' ...
    '    N = length(weights);\n' ...
    '    w_new = ones(1,N) / N;\n' ...
    '    c = cumsum(weights);\n' ...
    '    u = ([0:N-1] + rand()) / N;\n' ...
    '    p_new = zeros(size(particles));\n' ...
    '    i = 1;\n' ...
    '    for j = 1:N\n' ...
    '        while u(j) > c(i)\n' ...
    '            i = i + 1;\n' ...
    '        end\n' ...
    '        p_new(:,j) = particles(:,i);\n' ...
    '    end\n' ...
    'end\n']);

%% Strategy 3: Invariant Extended Kalman Filter (IEKF)
iekf_sys = [estimation_sys '/IEKF_Estimator'];
add_block('simulink/Ports & Subsystems/Subsystem', iekf_sys);

add_block('simulink/User-Defined Functions/MATLAB Function', [iekf_sys '/IEKF_Update']);
set_param([iekf_sys '/IEKF_Update'], 'Script', [...
    'function [x_est, P_est] = fcn(x_pred, P_pred, y, R)\n' ...
    '% Invariant Extended Kalman Filter update\n' ...
    '% Exploits group structure for improved consistency\n' ...
    'H = measurement_jacobian(x_pred);\n' ...
    'S = H * P_pred * H'' + R;\n' ...
    'K = P_pred * H'' / S;\n' ...
    '% Innovation\n' ...
    'h_pred = measurement_model_iekf(x_pred);\n' ...
    'innovation = y - h_pred;\n' ...
    '% Invariant correction\n' ...
    'delta_x = K * innovation;\n' ...
    'x_est = apply_correction(x_pred, delta_x);\n' ...
    'P_est = (eye(length(x_pred)) - K * H) * P_pred;\n' ...
    'function H = measurement_jacobian(x)\n' ...
    '    H = [eye(6), zeros(6,6)];\n' ...
    'end\n' ...
    'function h = measurement_model_iekf(x)\n' ...
    '    h = x(1:6);\n' ...
    'end\n' ...
    'function x_new = apply_correction(x, delta_x)\n' ...
    '    x_new = x + delta_x;\n' ...
    'end\n']);

%% === MULTI-SENSOR FUSION MANAGER ===
fusion_mgr = [modelName '/Fusion_Manager'];
add_block('simulink/Ports & Subsystems/Subsystem', fusion_mgr);

add_block('simulink/User-Defined Functions/MATLAB Function', [fusion_mgr '/Adaptive_Fusion']);
set_param([fusion_mgr '/Adaptive_Fusion'], 'Script', [...
    'function [x_fused, strategy_weights] = fcn(x_ukf, x_pf, x_iekf, P_ukf, P_pf, P_iekf)\n' ...
    '% Adaptive multi-strategy fusion using covariance intersection\n' ...
    '% Weight strategies based on their uncertainty\n' ...
    'trace_ukf = trace(P_ukf);\n' ...
    'trace_pf = trace(P_pf);\n' ...
    'trace_iekf = trace(P_iekf);\n' ...
    '% Inverse variance weighting\n' ...
    'w_ukf = 1 / (trace_ukf + eps);\n' ...
    'w_pf = 1 / (trace_pf + eps);\n' ...
    'w_iekf = 1 / (trace_iekf + eps);\n' ...
    '% Normalize weights\n' ...
    'total_weight = w_ukf + w_pf + w_iekf;\n' ...
    'w_ukf = w_ukf / total_weight;\n' ...
    'w_pf = w_pf / total_weight;\n' ...
    'w_iekf = w_iekf / total_weight;\n' ...
    '% Fused estimate\n' ...
    'x_fused = w_ukf * x_ukf + w_pf * x_pf + w_iekf * x_iekf;\n' ...
    'strategy_weights = [w_ukf; w_pf; w_iekf];\n']);

% Save model
save_system(modelName);
fprintf('✓ Advanced sensor fusion system created: %s.slx\n', modelName);

end

function create_guidance_navigation_system(params)
%% Advanced Guidance and Navigation System

fprintf('Creating advanced guidance and navigation system...\n');

modelName = 'advanced_guidance_navigation';
new_system(modelName);
open_system(modelName);

%% === MISSION PLANNING ===
mission_sys = [modelName '/Advanced_Mission_Planning'];
add_block('simulink/Ports & Subsystems/Subsystem', mission_sys);

% Dynamic mission replanning
add_block('simulink/User-Defined Functions/MATLAB Function', [mission_sys '/Dynamic_Replanning']);
set_param([mission_sys '/Dynamic_Replanning'], 'Script', [...
    'function [new_waypoints, replan_flag] = fcn(current_pos, waypoints, obstacles, weather)\n' ...
    '% Dynamic mission replanning with obstacle avoidance\n' ...
    'replan_flag = 0;\n' ...
    'new_waypoints = waypoints;\n' ...
    '% Check for obstacles in path\n' ...
    'for i = 1:size(obstacles,1)\n' ...
    '    obs_pos = obstacles(i,1:2);\n' ...
    '    obs_radius = obstacles(i,3);\n' ...
    '    % Check if obstacle blocks current path\n' ...
    '    if norm(current_pos(1:2) - obs_pos) < obs_radius + 5\n' ...
    '        replan_flag = 1;\n' ...
    '        % Generate alternative waypoints using RRT*\n' ...
    '        new_waypoints = rrt_star_planning(current_pos, waypoints(end,:), obstacles);\n' ...
    '        break;\n' ...
    '    end\n' ...
    'end\n' ...
    '% Weather-based replanning\n' ...
    'if weather.wind_speed > 10\n' ...
    '    replan_flag = 1;\n' ...
    '    % Adjust waypoints for wind\n' ...
    '    new_waypoints = adjust_for_wind(waypoints, weather);\n' ...
    'end\n' ...
    'function wp_new = rrt_star_planning(start, goal, obstacles)\n' ...
    '    % Simplified RRT* algorithm\n' ...
    '    wp_new = [start; (start+goal)/2; goal];\n' ...
    'end\n' ...
    'function wp_adj = adjust_for_wind(waypoints, weather)\n' ...
    '    wind_vector = [weather.wind_speed * cos(weather.wind_direction); weather.wind_speed * sin(weather.wind_direction)];\n' ...
    '    wp_adj = waypoints;\n' ...
    '    wp_adj(:,1:2) = wp_adj(:,1:2) - 0.1 * repmat(wind_vector'', size(wp_adj,1), 1);\n' ...
    'end\n']);

%% === ADVANCED GUIDANCE LAWS ===
guidance_sys = [modelName '/Advanced_Guidance_Laws'];
add_block('simulink/Ports & Subsystems/Subsystem', guidance_sys);

% Model Predictive Path Integral (MPPI) guidance
add_block('simulink/User-Defined Functions/MATLAB Function', [guidance_sys '/MPPI_Guidance']);
set_param([guidance_sys '/MPPI_Guidance'], 'Script', [...
    'function [u_optimal] = fcn(state, reference_path, obstacles, horizon)\n' ...
    '% Model Predictive Path Integral guidance\n' ...
    'N_samples = 1000;  % Number of sample trajectories\n' ...
    'N_horizon = horizon;\n' ...
    'lambda = 10;  % Temperature parameter\n' ...
    '% Generate random control sequences\n' ...
    'U_samples = 0.1 * randn(4, N_horizon, N_samples);  % 4 controls, horizon steps, samples\n' ...
    'costs = zeros(N_samples, 1);\n' ...
    '% Evaluate each sample trajectory\n' ...
    'for i = 1:N_samples\n' ...
    '    cost = evaluate_trajectory_cost(state, U_samples(:,:,i), reference_path, obstacles);\n' ...
    '    costs(i) = cost;\n' ...
    'end\n' ...
    '% Compute importance weights\n' ...
    'min_cost = min(costs);\n' ...
    'weights = exp(-lambda * (costs - min_cost));\n' ...
    'weights = weights / sum(weights);\n' ...
    '% Compute optimal control as weighted average\n' ...
    'u_optimal = zeros(4, 1);\n' ...
    'for i = 1:N_samples\n' ...
    '    u_optimal = u_optimal + weights(i) * U_samples(:,1,i);\n' ...
    'end\n' ...
    'function cost = evaluate_trajectory_cost(x0, U, ref_path, obstacles)\n' ...
    '    cost = 0;\n' ...
    '    x = x0;\n' ...
    '    dt = 0.1;\n' ...
    '    for k = 1:size(U,2)\n' ...
    '        % Simple dynamics integration\n' ...
    '        x = x + dt * [x(4:6); U(:,k)];\n' ...
    '        % Path tracking cost\n' ...
    '        path_error = norm(x(1:3) - ref_path(min(k,end),:)'');\n' ...
    '        cost = cost + path_error^2;\n' ...
    '        % Obstacle avoidance cost\n' ...
    '        for j = 1:size(obstacles,1)\n' ...
    '            obs_dist = norm(x(1:2) - obstacles(j,1:2)'');\n' ...
    '            if obs_dist < obstacles(j,3)\n' ...
    '                cost = cost + 1000;\n' ...
    '            end\n' ...
    '        end\n' ...
    '        % Control effort cost\n' ...
    '        cost = cost + 0.01 * norm(U(:,k))^2;\n' ...
    '    end\n' ...
    'end\n']);

% Artificial Potential Field with Dynamic Obstacles
add_block('simulink/User-Defined Functions/MATLAB Function', [guidance_sys '/Dynamic_APF']);
set_param([guidance_sys '/Dynamic_APF'], 'Script', [...
    'function [force_total] = fcn(position, velocity, goal, static_obs, dynamic_obs)\n' ...
    '% Artificial Potential Field with dynamic obstacle prediction\n' ...
    '% Attractive force toward goal\n' ...
    'k_att = 1.0;\n' ...
    'goal_vector = goal(1:3) - position(1:3);\n' ...
    'goal_distance = norm(goal_vector);\n' ...
    'if goal_distance > 0.1\n' ...
    '    F_att = k_att * goal_vector / goal_distance;\n' ...
    'else\n' ...
    '    F_att = [0; 0; 0];\n' ...
    'end\n' ...
    '% Repulsive force from static obstacles\n' ...
    'F_rep_static = [0; 0; 0];\n' ...
    'k_rep = 2.0;\n' ...
    'rho_0 = 3.0;  % Influence radius\n' ...
    'for i = 1:size(static_obs,1)\n' ...
    '    obs_pos = static_obs(i,1:3)'';\n' ...
    '    obs_radius = static_obs(i,4);\n' ...
    '    obs_vector = position(1:3) - obs_pos;\n' ...
    '    rho = norm(obs_vector) - obs_radius;\n' ...
    '    if rho < rho_0 && rho > 0\n' ...
    '        F_rep_static = F_rep_static + k_rep * (1/rho - 1/rho_0) * (1/rho^2) * (obs_vector/norm(obs_vector));\n' ...
    '    end\n' ...
    'end\n' ...
    '% Repulsive force from dynamic obstacles (with prediction)\n' ...
    'F_rep_dynamic = [0; 0; 0];\n' ...
    'prediction_time = 2.0;\n' ...
    'for i = 1:size(dynamic_obs,1)\n' ...
    '    obs_pos = dynamic_obs(i,1:3)'';\n' ...
    '    obs_vel = dynamic_obs(i,4:6)'';\n' ...
    '    obs_radius = dynamic_obs(i,7);\n' ...
    '    % Predict future obstacle position\n' ...
    '    obs_future = obs_pos + prediction_time * obs_vel;\n' ...
    '    % Compute relative position and velocity\n' ...
    '    rel_pos = position(1:3) - obs_future;\n' ...
    '    rel_vel = velocity(1:3) - obs_vel;\n' ...
    '    % Time to closest approach\n' ...
    '    if norm(rel_vel) > 0.1\n' ...
    '        t_cpa = -dot(rel_pos, rel_vel) / norm(rel_vel)^2;\n' ...
    '        if t_cpa > 0 && t_cpa < prediction_time\n' ...
    '            closest_distance = norm(rel_pos + t_cpa * rel_vel);\n' ...
    '            if closest_distance < obs_radius + 1.0\n' ...
    '                collision_risk = exp(-closest_distance);\n' ...
    '                avoidance_direction = cross(rel_vel, [0;0;1]);\n' ...
    '                avoidance_direction = avoidance_direction / (norm(avoidance_direction) + eps);\n' ...
    '                F_rep_dynamic = F_rep_dynamic + k_rep * collision_risk * avoidance_direction(1:3);\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n' ...
    '% Total force\n' ...
    'force_total = F_att + F_rep_static + F_rep_dynamic;\n' ...
    '% Limit maximum force\n' ...
    'max_force = 5.0;\n' ...
    'if norm(force_total) > max_force\n' ...
    '    force_total = max_force * force_total / norm(force_total);\n' ...
    'end\n']);

%% === COLLISION AVOIDANCE ===
collision_sys = [modelName '/Advanced_Collision_Avoidance'];
add_block('simulink/Ports & Subsystems/Subsystem', collision_sys);

% Velocity Obstacle (VO) method
add_block('simulink/User-Defined Functions/MATLAB Function', [collision_sys '/Velocity_Obstacles']);
set_param([collision_sys '/Velocity_Obstacles'], 'Script', [...
    'function [safe_velocity] = fcn(own_pos, own_vel, obstacles, desired_vel)\n' ...
    '% Velocity Obstacles collision avoidance\n' ...
    'safe_velocity = desired_vel;\n' ...
    'safety_margin = 0.5;  % Safety margin [m]\n' ...
    'max_speed = 5.0;      % Maximum speed [m/s]\n' ...
    '% For each obstacle, compute velocity obstacle\n' ...
    'forbidden_velocities = [];\n' ...
    'for i = 1:size(obstacles,1)\n' ...
    '    obs_pos = obstacles(i,1:2)'';\n' ...
    '    obs_vel = obstacles(i,3:4)'';\n' ...
    '    obs_radius = obstacles(i,5) + safety_margin;\n' ...
    '    % Relative position and velocity\n' ...
    '    rel_pos = obs_pos - own_pos(1:2);\n' ...
    '    rel_dist = norm(rel_pos);\n' ...
    '    if rel_dist < 10.0  % Only consider nearby obstacles\n' ...
    '        % Velocity obstacle cone\n' ...
    '        if rel_dist > obs_radius\n' ...
    '            % Tangent angles\n' ...
    '            sin_alpha = obs_radius / rel_dist;\n' ...
    '            cos_alpha = sqrt(1 - sin_alpha^2);\n' ...
    '            % Rotate relative position vector\n' ...
    '            R1 = [cos_alpha, -sin_alpha; sin_alpha, cos_alpha];\n' ...
    '            R2 = [cos_alpha, sin_alpha; -sin_alpha, cos_alpha];\n' ...
    '            tang1 = R1 * rel_pos;\n' ...
    '            tang2 = R2 * rel_pos;\n' ...
    '            % Check if current velocity is in VO\n' ...
    '            rel_vel = own_vel(1:2) - obs_vel;\n' ...
    '            if is_in_cone(rel_vel, tang1, tang2)\n' ...
    '                % Find closest safe velocity\n' ...
    '                safe_velocity(1:2) = find_safe_velocity(own_vel(1:2), obs_vel, tang1, tang2, max_speed);\n' ...
    '            end\n' ...
    '        end\n' ...
    '    end\n' ...
    'end\n' ...
    'function in_cone = is_in_cone(v, t1, t2)\n' ...
    '    cross1 = v(1)*t1(2) - v(2)*t1(1);\n' ...
    '    cross2 = v(1)*t2(2) - v(2)*t2(1);\n' ...
    '    in_cone = (cross1 >= 0 && cross2 <= 0) || (cross1 <= 0 && cross2 >= 0);\n' ...
    'end\n' ...
    'function v_safe = find_safe_velocity(v_own, v_obs, t1, t2, v_max)\n' ...
    '    % Simple avoidance: move perpendicular to collision course\n' ...
    '    rel_vel = v_own - v_obs;\n' ...
    '    perp_dir = [-rel_vel(2); rel_vel(1)];\n' ...
    '    perp_dir = perp_dir / (norm(perp_dir) + eps);\n' ...
    '    v_safe = v_obs + 0.5 * v_max * perp_dir;\n' ...
    'end\n']);

% Save model
save_system(modelName);
fprintf('✓ Advanced guidance and navigation system created: %s.slx\n', modelName);

end

function create_flight_test_environment(params)
%% Professional Flight Test Environment

fprintf('Creating professional flight test environment...\n');

modelName = 'flight_test_environment';
new_system(modelName);
open_system(modelName);

%% === AUTOMATED TEST SUITE ===
test_suite = [modelName '/Automated_Test_Suite'];
add_block('simulink/Ports & Subsystems/Subsystem', test_suite);

% Test sequence manager
add_block('simulink/User-Defined Functions/MATLAB Function', [test_suite '/Test_Manager']);
set_param([test_suite '/Test_Manager'], 'Script', [...
    'function [test_command, test_phase] = fcn(time, test_complete)\n' ...
    '% Automated test sequence manager\n' ...
    'persistent current_test test_start_time\n' ...
    'if isempty(current_test)\n' ...
    '    current_test = 1;\n' ...
    '    test_start_time = time;\n' ...
    'end\n' ...
    'test_duration = 30;  % Each test duration in seconds\n' ...
    'if time - test_start_time > test_duration || test_complete\n' ...
    '    current_test = current_test + 1;\n' ...
    '    test_start_time = time;\n' ...
    'end\n' ...
    'test_phase = mod(time - test_start_time, test_duration);\n' ...
    'switch current_test\n' ...
    '    case 1  % Hover stability test\n' ...
    '        test_command = [0; 0; -2; 0];  % Hold position at 2m altitude\n' ...
    '    case 2  % Vertical maneuver test\n' ...
    '        test_command = [0; 0; -2 - 2*sin(0.1*time); 0];\n' ...
    '    case 3  % Horizontal figure-8 test\n' ...
    '        test_command = [5*sin(0.1*time); 5*cos(0.2*time); -3; 0];\n' ...
    '    case 4  % Aggressive maneuver test\n' ...
    '        test_command = [2*sin(0.5*time); 2*cos(0.5*time); -2-sin(0.3*time); 0.5*sin(0.2*time)];\n' ...
    '    case 5  % Wind disturbance test\n' ...
    '        test_command = [0; 0; -2; 0];  % Hover with wind\n' ...
    '    otherwise\n' ...
    '        test_command = [0; 0; 0; 0];  % Landing\n' ...
    'end\n']);

%% === REAL-TIME PERFORMANCE ANALYSIS ===
analysis_sys = [modelName '/Real_Time_Analysis'];
add_block('simulink/Ports & Subsystems/Subsystem', analysis_sys);

% Performance metrics computation
add_block('simulink/User-Defined Functions/MATLAB Function', [analysis_sys '/Performance_Metrics']);
set_param([analysis_sys '/Performance_Metrics'], 'Script', [...
    'function [metrics] = fcn(position, velocity, reference, control_input)\n' ...
    '% Real-time performance metrics computation\n' ...
    'persistent pos_error_history vel_history control_history\n' ...
    'if isempty(pos_error_history)\n' ...
    '    pos_error_history = [];\n' ...
    '    vel_history = [];\n' ...
    '    control_history = [];\n' ...
    'end\n' ...
    '% Position tracking error\n' ...
    'pos_error = norm(position(1:3) - reference(1:3));\n' ...
    'pos_error_history = [pos_error_history, pos_error];\n' ...
    'if length(pos_error_history) > 1000\n' ...
    '    pos_error_history = pos_error_history(end-999:end);\n' ...
    'end\n' ...
    '% Velocity tracking\n' ...
    'vel_magnitude = norm(velocity(1:3));\n' ...
    'vel_history = [vel_history, vel_magnitude];\n' ...
    'if length(vel_history) > 1000\n' ...
    '    vel_history = vel_history(end-999:end);\n' ...
    'end\n' ...
    '% Control effort\n' ...
    'control_effort = norm(control_input);\n' ...
    'control_history = [control_history, control_effort];\n' ...
    'if length(control_history) > 1000\n' ...
    '    control_history = control_history(end-999:end);\n' ...
    'end\n' ...
    '% Compute metrics\n' ...
    'metrics = struct();\n' ...
    'metrics.rms_position_error = sqrt(mean(pos_error_history.^2));\n' ...
    'metrics.max_position_error = max(pos_error_history);\n' ...
    'metrics.mean_velocity = mean(vel_history);\n' ...
    'metrics.rms_control_effort = sqrt(mean(control_history.^2));\n' ...
    'metrics.control_efficiency = metrics.rms_position_error / (metrics.rms_control_effort + eps);\n']);

%% === FAULT INJECTION SYSTEM ===
fault_sys = [modelName '/Fault_Injection'];
add_block('simulink/Ports & Subsystems/Subsystem', fault_sys);

% Actuator fault injection
add_block('simulink/User-Defined Functions/MATLAB Function', [fault_sys '/Actuator_Faults']);
set_param([fault_sys '/Actuator_Faults'], 'Script', [...
    'function [motor_cmd_faulty] = fcn(motor_cmd_clean, time, fault_enable)\n' ...
    '% Realistic actuator fault injection\n' ...
    'motor_cmd_faulty = motor_cmd_clean;\n' ...
    'if fault_enable\n' ...
    '    % Motor failure scenario\n' ...
    '    if time > 10 && time < 15\n' ...
    '        motor_cmd_faulty(1) = 0;  % Complete motor 1 failure\n' ...
    '    end\n' ...
    '    % Partial motor degradation\n' ...
    '    if time > 20 && time < 25\n' ...
    '        motor_cmd_faulty(2) = 0.5 * motor_cmd_faulty(2);  % 50% power loss\n' ...
    '    end\n' ...
    '    % ESC glitch\n' ...
    '    if mod(time, 5) < 0.1 && time > 5\n' ...
    '        motor_cmd_faulty(3) = 0;  % Intermittent ESC failure\n' ...
    '    end\n' ...
    '    % Actuator saturation\n' ...
    '    if time > 30\n' ...
    '        motor_cmd_faulty = max(0.1, min(0.9, motor_cmd_faulty));  % Reduced range\n' ...
    '    end\n' ...
    'end\n']);

% Sensor fault injection
add_block('simulink/User-Defined Functions/MATLAB Function', [fault_sys '/Sensor_Faults']);
set_param([fault_sys '/Sensor_Faults'], 'Script', [...
    'function [sensor_out] = fcn(sensor_in, time, fault_type)\n' ...
    '% Realistic sensor fault injection\n' ...
    'sensor_out = sensor_in;\n' ...
    'switch fault_type\n' ...
    '    case 1  % Bias drift\n' ...
    '        bias = 0.1 * time * [1; 1; 1];\n' ...
    '        sensor_out = sensor_out + bias;\n' ...
    '    case 2  % Scale factor error\n' ---
    '        scale_error = 1 + 0.05 * sin(0.1 * time);\n' ...
    '        sensor_out = scale_error * sensor_out;\n' ...
    '    case 3  % Intermittent failure\n' ...
    '        if mod(time, 10) < 1\n' ---
    '            sensor_out = sensor_out * 0;\n' ...
    '        end\n' ...
    '    case 4  % Stuck sensor\n' ...
    '        if time > 15\n' ...
    '            sensor_out = sensor_in;  % Output doesn''t change\n' ...
    '        end\n' ...
    '    case 5  % High noise\n' ...
    '        noise = 0.5 * randn(size(sensor_in));\n' ...
    '        sensor_out = sensor_out + noise;\n' ...
    'end\n']);

% Save model
save_system(modelName);
fprintf('✓ Professional flight test environment created: %s.slx\n', modelName);

end
