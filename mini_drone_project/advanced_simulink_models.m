function create_advanced_simulink_models(params)
%% Advanced Simulink Model Generation
% Creates state-of-the-art Simulink models with professional features

fprintf('\n=== Creating Advanced Simulink Models ===\n');

%% 1. Ultra-High Fidelity Drone Dynamics Model
create_ultra_hifi_dynamics_model(params);

%% 2. Advanced Nonlinear Control System
create_advanced_control_system(params);

%% 3. High-Fidelity Sensor Fusion System
create_sensor_fusion_system(params);

%% 4. Advanced Guidance and Navigation
create_guidance_navigation_system(params);

%% 5. Professional Flight Test Environment
create_flight_test_environment(params);

end

function create_ultra_hifi_dynamics_model(params)
%% Ultra-High Fidelity 6-DOF Dynamics with Advanced Physics

fprintf('Creating ultra-high fidelity dynamics model...\n');

modelName = 'ultra_hifi_drone_dynamics';
new_system(modelName);
open_system(modelName);

% Model configuration for high performance
set_param(modelName, 'Solver', 'ode15s');  % Stiff solver for complex dynamics
set_param(modelName, 'MaxStep', '1e-4');   % High resolution
set_param(modelName, 'RelTol', '1e-8');    % High precision
set_param(modelName, 'AbsTol', '1e-10');

%% === ADVANCED AERODYNAMICS SUBSYSTEM ===
aero_sys = [modelName '/Advanced_Aerodynamics'];
add_block('simulink/Ports & Subsystems/Subsystem', aero_sys);

% Momentum Theory + Blade Element Model
add_block('aerospace/Propulsion/Propeller', [aero_sys '/Propeller_BEM']);
set_param([aero_sys '/Propeller_BEM'], ...
    'diameter', num2str(params.propulsion.prop.diameter), ...
    'pitch', num2str(params.propulsion.prop.pitch), ...
    'ModelDetail', 'Blade element momentum theory');

% Rotor Dynamics with Flapping
add_block('simulink/Continuous/Transfer Fcn', [aero_sys '/Blade_Flapping']);
flapping_tf = tf([params.aero.rotor.blade_flapping_freq^2], ...
                [1, 2*0.1*params.aero.rotor.blade_flapping_freq, params.aero.rotor.blade_flapping_freq^2]);
set_param([aero_sys '/Blade_Flapping'], 'Numerator', mat2str(flapping_tf.Numerator{1}), ...
    'Denominator', mat2str(flapping_tf.Denominator{1}));

% Ground Effect Model
add_block('simulink/User-Defined Functions/MATLAB Function', [aero_sys '/Ground_Effect']);
set_param([aero_sys '/Ground_Effect'], 'Script', [...
    'function thrust_multiplier = fcn(altitude)\n' ...
    'h_threshold = ' num2str(params.aero.ground_effect.height_threshold) ';\n' ...
    'gain = ' num2str(params.aero.ground_effect.efficiency_gain) ';\n' ...
    'if altitude < h_threshold\n' ...
    '    thrust_multiplier = 1 + gain * exp(-altitude/h_threshold);\n' ...
    'else\n' ...
    '    thrust_multiplier = 1;\n' ...
    'end']);

% Vortex Ring State Detection
add_block('simulink/User-Defined Functions/MATLAB Function', [aero_sys '/VRS_Detection']);
set_param([aero_sys '/VRS_Detection'], 'Script', [...
    'function power_factor = fcn(vertical_velocity, collective)\n' ...
    'vrs_onset = ' num2str(params.aero.vrs.onset_velocity) ';\n' ...
    'power_increase = ' num2str(params.aero.vrs.power_increase) ';\n' ...
    'if vertical_velocity < vrs_onset && collective > 0.3\n' ...
    '    vrs_severity = abs(vertical_velocity - vrs_onset) / abs(vrs_onset);\n' ...
    '    power_factor = 1 + power_increase * vrs_severity;\n' ...
    'else\n' ...
    '    power_factor = 1;\n' ...
    'end']);

%% === ADVANCED PROPULSION SYSTEM ===
prop_sys = [modelName '/Advanced_Propulsion'];
add_block('simulink/Ports & Subsystems/Subsystem', prop_sys);

% 3-Phase BLDC Motor Model
add_block('simulink/User-Defined Functions/MATLAB Function', [prop_sys '/BLDC_Motor']);
set_param([prop_sys '/BLDC_Motor'], 'Script', [...
    'function [torque, current, rpm] = fcn(voltage, load_torque)\n' ...
    'kv = ' num2str(params.propulsion.motor.kv) ';\n' ...
    'kt = ' num2str(params.propulsion.motor.kt) ';\n' ...
    'R = ' num2str(params.propulsion.motor.resistance) ';\n' ...
    'rpm = kv * voltage;\n' ...
    'back_emf = rpm / kv;\n' ...
    'current = (voltage - back_emf) / R;\n' ...
    'torque = kt * current - load_torque;\n']);

% Advanced ESC with PWM Dynamics
add_block('simulink/Discrete/Zero-Order Hold', [prop_sys '/ESC_PWM']);
set_param([prop_sys '/ESC_PWM'], 'SampleTime', num2str(1/params.propulsion.esc.update_rate));

% Propeller CFD-Based Model
add_block('simulink/Lookup Tables/1-D Lookup Table', [prop_sys '/Prop_CT_Lookup']);
set_param([prop_sys '/Prop_CT_Lookup'], ...
    'Table', mat2str(params.propulsion.prop.ct_curve), ...
    'BreakpointsForDimension1', mat2str(params.propulsion.prop.advance_ratio));

%% === STRUCTURAL DYNAMICS ===
struct_sys = [modelName '/Structural_Dynamics'];
add_block('simulink/Ports & Subsystems/Subsystem', struct_sys);

% Modal Superposition for Flexible Body
for i = 1:length(params.structure.modes.frequencies)
    mode_block = [struct_sys '/Mode_' num2str(i)];
    add_block('simulink/Continuous/Transfer Fcn', mode_block);
    
    % Create modal transfer function
    omega_n = 2*pi*params.structure.modes.frequencies(i);
    zeta = params.structure.modes.damping(i);
    modal_tf = tf([omega_n^2], [1, 2*zeta*omega_n, omega_n^2]);
    
    set_param(mode_block, ...
        'Numerator', mat2str(modal_tf.Numerator{1}), ...
        'Denominator', mat2str(modal_tf.Denominator{1}));
end

%% === ADVANCED 6-DOF EQUATIONS OF MOTION ===
eom_sys = [modelName '/Advanced_6DOF_EOM'];
add_block('aerospace/Equations of Motion/6DOF (Euler Angles)', eom_sys);

% Configure for high-fidelity simulation
set_param(eom_sys, ...
    'mass', num2str(params.aero.rotor.radius * 4 * 0.087), ...
    'inertia', '[1.4e-5, 0, 0; 0, 1.4e-5, 0; 0, 0, 2.17e-5]', ...
    'InitialPositionVelocity', '[0 0 0 0 0 0]', ...
    'InitialEulerAngles', '[0 0 0]', ...
    'InitialAngularVelocity', '[0 0 0]');

%% === ENVIRONMENTAL EFFECTS ===
env_sys = [modelName '/Environmental_Effects'];
add_block('simulink/Ports & Subsystems/Subsystem', env_sys);

% Dryden Wind Turbulence Model
add_block('aerospace/Environment/Dryden Wind Turbulence Model (Continuous)', [env_sys '/Dryden_Wind']);
set_param([env_sys '/Dryden_Wind'], ...
    'wingspan', num2str(params.environment.wind.dryden.wingspan), ...
    'altitude', num2str(params.environment.wind.dryden.altitude), ...
    'WindSpeed', '5', ...
    'TurbulenceIntensity', 'Moderate');

% Atmospheric Model (ISA + Variations)
add_block('aerospace/Environment/COESA Atmosphere Model', [env_sys '/Atmosphere']);

% Temperature Effects on Performance
add_block('simulink/User-Defined Functions/MATLAB Function', [env_sys '/Temperature_Effects']);
set_param([env_sys '/Temperature_Effects'], 'Script', [...
    'function density_ratio = fcn(altitude, temperature)\n' ...
    'rho_0 = 1.225;\n' ...
    'T_0 = 288.15;\n' ...
    'lapse_rate = ' num2str(params.environment.atmosphere.temperature_lapse) ';\n' ...
    'T_alt = T_0 + lapse_rate * altitude;\n' ...
    'rho_alt = rho_0 * (T_alt / T_0)^(-1 - 9.81/(287*lapse_rate));\n' ...
    'density_ratio = rho_alt / rho_0;\n']);

%% Connect all subsystems
% Create bus objects for clean signal routing
bus_info = Simulink.Bus.createObject([aero_sys, prop_sys, struct_sys, eom_sys, env_sys]);

% Save model
save_system(modelName);
fprintf('✓ Ultra-high fidelity dynamics model created: %s.slx\n', modelName);

end

function create_advanced_control_system(params)
%% Advanced Nonlinear Control with Multiple Strategies

fprintf('Creating advanced control system...\n');

modelName = 'advanced_control_system';
new_system(modelName);
open_system(modelName);

%% === CONTROL ARCHITECTURE SELECTOR ===
% Multi-strategy control system
ctrl_selector = [modelName '/Control_Strategy_Selector'];
add_block('simulink/Signal Routing/Manual Switch', ctrl_selector);
set_param(ctrl_selector, 'Inputs', '4');  % 4 control strategies

%% === STRATEGY 1: NONLINEAR DYNAMIC INVERSION (NDI) ===
ndi_sys = [modelName '/NDI_Controller'];
add_block('simulink/Ports & Subsystems/Subsystem', ndi_sys);

% Virtual control computation
add_block('simulink/User-Defined Functions/MATLAB Function', [ndi_sys '/Virtual_Control']);
set_param([ndi_sys '/Virtual_Control'], 'Script', [...
    'function [nu_cmd] = fcn(x_ref, x_actual, x_dot_ref)\n' ...
    '% Nonlinear Dynamic Inversion virtual control\n' ...
    'K = diag([' num2str(params.control.ndi.bandwidth) ']);\n' ...
    'e = x_ref - x_actual;\n' ...
    'nu_cmd = x_dot_ref + K * e;\n']);

% Control allocation with pseudo-inverse
add_block('simulink/User-Defined Functions/MATLAB Function', [ndi_sys '/Control_Allocation']);
set_param([ndi_sys '/Control_Allocation'], 'Script', [...
    'function [motor_cmds] = fcn(virtual_control, effectiveness_matrix)\n' ...
    '% Pseudo-inverse control allocation\n' ...
    'B = effectiveness_matrix;\n' ...
    'motor_cmds = pinv(B) * virtual_control;\n' ...
    '% Apply saturation\n' ...
    'motor_cmds = max(0, min(1, motor_cmds));\n']);

%% === STRATEGY 2: MODEL REFERENCE ADAPTIVE CONTROL (MRAC) ===
mrac_sys = [modelName '/MRAC_Controller'];
add_block('simulink/Ports & Subsystems/Subsystem', mrac_sys);

% Reference model
add_block('simulink/Continuous/Transfer Fcn', [mrac_sys '/Reference_Model']);
ref_model = params.control.mrac.reference_model;
set_param([mrac_sys '/Reference_Model'], ...
    'Numerator', mat2str(ref_model.Numerator{1}), ...
    'Denominator', mat2str(ref_model.Denominator{1}));

% Adaptive law with σ-modification
add_block('simulink/User-Defined Functions/MATLAB Function', [mrac_sys '/Adaptive_Law']);
set_param([mrac_sys '/Adaptive_Law'], 'Script', [...
    'function [theta_dot] = fcn(error, phi, theta, gamma, sigma)\n' ...
    '% MRAC adaptive law with σ-modification\n' ...
    'theta_dot = -gamma * phi * error - sigma * theta;\n']);

%% === STRATEGY 3: L1 ADAPTIVE CONTROL ===
l1_sys = [modelName '/L1_Adaptive_Controller'];
add_block('simulink/Ports & Subsystems/Subsystem', l1_sys);

% L1 predictor
add_block('simulink/User-Defined Functions/MATLAB Function', [l1_sys '/L1_Predictor']);
set_param([l1_sys '/L1_Predictor'], 'Script', [...
    'function [x_pred_dot] = fcn(x_pred, u, sigma_hat)\n' ...
    '% L1 adaptive predictor\n' ...
    'A_m = [-' num2str(params.control.l1.predictor_bandwidth) '];\n' ...
    'B_m = [' num2str(params.control.l1.predictor_bandwidth) '];\n' ...
    'x_pred_dot = A_m * x_pred + B_m * (u + sigma_hat);\n']);

% L1 adaptation law
add_block('simulink/Continuous/Integrator', [l1_sys '/Sigma_Adaptation']);
add_block('simulink/User-Defined Functions/MATLAB Function', [l1_sys '/Projection_Operator']);

%% === STRATEGY 4: INCREMENTAL NDI (INDI) ===
indi_sys = [modelName '/INDI_Controller'];
add_block('simulink/Ports & Subsystems/Subsystem', indi_sys);

% Angular acceleration estimation
add_block('simulink/Continuous/Derivative', [indi_sys '/Angular_Accel_Est']);
set_param([indi_sys '/Angular_Accel_Est'], 'InitialCondition', '0');

% High-pass filter for noise reduction
add_block('simulink/Continuous/Transfer Fcn', [indi_sys '/Accel_Filter']);
omega_f = 2*pi*params.control.indi.angular_accel_filter;
filter_tf = tf([1, 0], [1/omega_f, 1]);
set_param([indi_sys '/Accel_Filter'], ...
    'Numerator', mat2str(filter_tf.Numerator{1}), ...
    'Denominator', mat2str(filter_tf.Denominator{1}));

%% === CONTROL MIXER AND ALLOCATION ===
mixer_sys = [modelName '/Advanced_Control_Mixer'];
add_block('simulink/Ports & Subsystems/Subsystem', mixer_sys);

% Optimal control allocation with constraints
add_block('simulink/User-Defined Functions/MATLAB Function', [mixer_sys '/Optimal_Allocation']);
set_param([mixer_sys '/Optimal_Allocation'], 'Script', [...
    'function [u_opt] = fcn(v_cmd, B, u_min, u_max, u_pref)\n' ...
    '% Quadratic programming control allocation\n' ...
    '% Minimize: (u-u_pref)^T*W*(u-u_pref)\n' ...
    '% Subject to: B*u = v_cmd, u_min <= u <= u_max\n' ...
    'n = size(B,2);\n' ...
    'W = eye(n);\n' ...
    'H = 2*W;\n' ...
    'f = -2*W*u_pref;\n' ...
    'Aeq = B;\n' ...
    'beq = v_cmd;\n' ...
    'lb = u_min;\n' ...
    'ub = u_max;\n' ...
    'options = optimoptions(''quadprog'', ''Display'', ''off'');\n' ...
    'u_opt = quadprog(H, f, [], [], Aeq, beq, lb, ub, [], options);\n' ...
    'if isempty(u_opt)\n' ...
    '    u_opt = pinv(B) * v_cmd;\n' ...
    '    u_opt = max(u_min, min(u_max, u_opt));\n' ...
    'end\n']);

%% === ADVANCED GUIDANCE LAWS ===
guidance_sys = [modelName '/Advanced_Guidance'];
add_block('simulink/Ports & Subsystems/Subsystem', guidance_sys);

% Vector field guidance
add_block('simulink/User-Defined Functions/MATLAB Function', [guidance_sys '/Vector_Field_Guidance']);
set_param([guidance_sys '/Vector_Field_Guidance'], 'Script', [...
    'function [chi_c] = fcn(pos, waypoint, k_path, k_orbit)\n' ...
    '% Vector field path following guidance\n' ...
    'e = pos(1:2) - waypoint(1:2);\n' ...
    'e_norm = norm(e);\n' ...
    'if e_norm < 1e-6\n' ...
    '    chi_c = 0;\n' ...
    'else\n' ...
    '    chi_path = atan2(waypoint(2)-pos(2), waypoint(1)-pos(1));\n' ...
    '    chi_orbit = atan2(-e(1), e(2)) + pi/2;\n' ...
    '    w_path = 2/pi * atan(k_path * e_norm);\n' ...
    '    w_orbit = 1 - w_path;\n' ...
    '    chi_c = w_path * chi_path + w_orbit * chi_orbit;\n' ...
    'end\n']);

% Pure pursuit guidance
add_block('simulink/User-Defined Functions/MATLAB Function', [guidance_sys '/Pure_Pursuit']);
set_param([guidance_sys '/Pure_Pursuit'], 'Script', [...
    'function [chi_c] = fcn(pos, vel, waypoint, lookahead)\n' ...
    '% Pure pursuit guidance law\n' ...
    'rel_pos = waypoint(1:2) - pos(1:2);\n' ...
    'range = norm(rel_pos);\n' ...
    'if range < lookahead\n' ...
    '    chi_c = atan2(rel_pos(2), rel_pos(1));\n' ...
    'else\n' ...
    '    vel_2d = vel(1:2);\n' ...
    '    speed = norm(vel_2d);\n' ...
    '    if speed > 0.1\n' ...
    '        heading = atan2(vel_2d(2), vel_2d(1));\n' ...
    '        bearing = atan2(rel_pos(2), rel_pos(1));\n' ...
    '        eta = bearing - heading;\n' ...
    '        chi_c = heading + 2*asin(sin(eta/2) * range/lookahead);\n' ...
    '    else\n' ...
    '        chi_c = atan2(rel_pos(2), rel_pos(1));\n' ...
    '    end\n' ...
    'end\n']);

% Save model
save_system(modelName);
fprintf('✓ Advanced control system created: %s.slx\n', modelName);

end
